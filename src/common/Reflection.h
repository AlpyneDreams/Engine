#pragma once

#include <typeinfo>
#include <typeindex>
#include <string>
#include <vector>
#include <unordered_map>
#include <cstddef>

#include <entt/core/type_info.hpp>

namespace engine
{
    /** Extend this class to enable RTTI generation for subclasses. */
    struct Reflect {};
};

namespace engine::refl
{
    using Type = entt::type_info;
    using Hash = entt::id_type;
    
    // Get type info.
    // Has to be function not variable or else we can get invalid results sometimes
    template <typename T>
    Type TypeID() { return entt::type_id<T>(); }

    // Type hashes (constexpr)
    template <typename T>
    constexpr Hash TypeHash = entt::type_hash<T>::value();

    struct Field
    {
        const char* name;
        const char* displayName;
        Type type;
        size_t offset;

        template <typename T>
        T* GetPointer(void* obj) const {
            return reinterpret_cast<T*>((char*)obj + offset);
        }

        template <typename T>
        T& Get(void* obj) const {
            return *GetPointer<T>(obj);
        }
    };

    struct Class
    {
        const char* name;
        const char* displayName;
        Type type = TypeID<nullptr_t>();
        size_t size;
        std::vector<Field> fields;

        static inline Class& Register(Class&& c) {
            classes.insert({ c.type.hash(), c });
            return c;
        }

        static inline Class* Get(Hash hash) {
            return classes.contains(hash) ? &classes.at(hash) : nullptr;
        }

        static inline Class* Get(Type type) {
            return Get(type.hash());
        }

        static inline std::unordered_map<Hash, Class> classes;
    };
};

// This namespace contains all autogenerated RTTI data.
namespace engine::rtti
{
    using namespace engine::refl;

    template <class T>
    Class RTTI;
};